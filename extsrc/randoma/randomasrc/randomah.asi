; ----------------------------- RANDOMAH.ASI ---------------------------
; Author:        Agner Fog
; Date created:  2001
; Last modified: 2008-12-02
; Project:       randoma library of random number generators
; Source URL:    www.agner.org/random
; Description:
; Assembly include file containing
; structure/class definitions for random number generators
;
; Copyright 2001-2008 by Agner Fog. 
; GNU General Public License http://www.gnu.org/licenses/gpl.html
; ----------------------------------------------------------------------


; ***************************************************************************
; Macros for making position-independent code, used in 32-bit mode only
; ***************************************************************************

; Macro for arbitrary instruction with position-independent reference
PICREFERENCE MACRO TARGET, REFPOINT, BYTE1, BYTE2, BYTE3
; Make position-independent instrution, for example:
; add eax, [ebx+TARGET-REFPOINT]
; where ebx contains the address of REFPOINT
; BYTE1, BYTE2, BYTE3 are the first 2 or 3 bytes of the instruction
; add eax, [ebx+????]
; (as obtained from an assembly listing) including opcode byte, 
; mod/reg/rm byte and possibly sib byte, but not including the 4-bytes 
; offset which is generated by this macro.
; Any instruction and any registers can be coded into BYTE1, BYTE2, BYTE3.

local p0, p1, p2
; Insert byte codes except last one
p0:
   db  BYTE1
IFNB  <BYTE3>      ; if BYTE3 not blank
   db  BYTE2
ENDIF   
p1:   
; Make bogus CALL instruction for making self-relative reference.
; This is the only way the assembler can make a self-relative reference
   call near ptr TARGET + (p2-REFPOINT) 
p2:
; back-patch CALL instruction to change it to the desired instruction
; by replacing CALL opcode by the last byte of desired instruction
   org p1
IFNB  <BYTE3>      ; if BYTE3 not blank
   db  BYTE3
ELSE
   db  BYTE2
ENDIF
   org p2          ; Back to end of instruction
ENDM


; Load offset of TARGET into ecx. Use position-independent method if necessary
LOADOFFSET2ECX MACRO TARGET 
LOCAL   Refp
IFNDEF  POSITIONINDEPENDENT
        mov     ecx, offset TARGET
ELSE
        ; get position-independent address of TARGET
        call    get_thunk_ecx
Refp:   ; Use PICREFERENCE to make instruction: add ecx, TARGET - Refp
        PICREFERENCE TARGET, Refp, 81h, 0C1h
ENDIF
ENDM       

; Load offset of TARGET into edi. Use position-independent method if necessary
LOADOFFSET2EDI MACRO TARGET 
LOCAL   Refp
IFNDEF  POSITIONINDEPENDENT
        mov     edi, offset TARGET
ELSE
        ; get position-independent address of TARGET
        call    get_thunk_edi
Refp:   ; Use PICREFERENCE to make instruction: add edi, TARGET - Refp
        PICREFERENCE TARGET, Refp, 81h, 0C7h
ENDIF
ENDM


; ***************************************************************************
; Define registers used for function parameters, used in 64-bit mode only
; ***************************************************************************
 
IFDEF WINDOWS
  par1   equ  rcx
  par2   equ  rdx
  par3   equ  r8
  par4   equ  r9
  par5   equ  qword ptr [rsp+40]
  par1d  equ  ecx
  par2d  equ  edx
  par3d  equ  r8d
  par4d  equ  r9d
  par5d  equ  dword ptr [rsp+40]
ENDIF
  
IFDEF UNIX
  par1   equ  rdi
  par2   equ  rsi
  par3   equ  rdx
  par4   equ  rcx
  par5   equ  r8
  par1d  equ  edi
  par2d  equ  esi
  par3d  equ  edx
  par4d  equ  ecx
  par5d  equ  r8d
ENDIF 
       

; ***************************************************************************
; Definitions for Mersenne Twister:
; ***************************************************************************

IF 0
; define constants for MT11213A:
MERS_N    = 351
MERS_M    = 175
MERS_R    = 19
MERS_A    = 0E4BD75F5H
MERS_U    = 11
MERS_S    = 7
MERS_T    = 15
MERS_L    = 17
MERS_B    = 655E5280H
MERS_C    = 0FFD58000H

ELSE
; or constants for MT19937:
MERS_N    = 624
MERS_M    = 397
MERS_R    = 31
MERS_A    = 09908B0DFH
MERS_U    = 11
MERS_S    = 7
MERS_T    = 15
MERS_L    = 18
MERS_B    = 9D2C5680H
MERS_C    = 0EFC60000H

ENDIF

LOWER_MASK = (1 SHL MERS_R) - 1             ; lower MERS_R bits
UPPER_MASK = -1 SHL MERS_R                  ; upper 32-MERS_R bits

; Define class CRandomMersenneA member data
; Must be aligned by 16.

CRandomMersenneA STRUC
Fill    DD      4 dup (?)              ; Alignment filler
PreInt  DD      ?, ?, ?, ?             ; premade tempered integer numbers, ready to use
PreFlt  DQ      ?, ?, ?, ?             ; premade floating point numbers, ready to use (subtract 1.0)
        DQ      ?                      ; last PreFlt unaligned overrun if MERS_N mod 4 = 1
TmpFlt  DQ      ?                      ; temporary storage of floating point random number
PreInx  DD      ?                      ; index to next PreInt and PreFlt number
Instset DD      ?                      ; Instruction set
LastInterval DD ?                      ; Last interval length for IRandomX
RLimit  DD      ?                      ; Rejection limit used by IRandomX
TMB     DD      4 dup (?)              ; 4 copies of MERS_B constant
TMC     DD      4 dup (?)              ; 4 copies of MERS_C constant
one     DQ      2 dup (?)              ; 2 copies of 1.0 constant
MTI     DD      ?                      ; index into MT buffer
UMASK   DD      ?                      ; UPPER_MASK
LMASK   DD      ?                      ; LOWER_MASK             ; constants
MATA    DD      ?                      ; MERS_A
wrap1   DD      4  dup (?)             ; MT buffer km wraparound
MT      DD      MERS_N  dup (?)        ; MT history buffer (aligned by 16)
wrap2   DD      4  dup (?)             ; MT buffer kk wraparound
IF MERS_N AND 3
        ; MERS_N not divisible by 4. align by 4
        DD      (4 - (MERS_N AND 3)) dup (?)
ENDIF        
CRandomMersenneA ENDS


; ***************************************************************************
; Definitions for Mother-of-all generator:
; ***************************************************************************

; Define class CRandomMotherA member data
; Must be aligned by 16. Preferably aligned by 64 to fit a cache line
CRandomMotherA STRUC
Fill    DD      4 dup (?)              ; Filler for adjusting random alignment
M0      DD      ?                      ; x[n]
M1      DD      ?                      ; x[n-1]
M2      DD      ?                      ; x[n-2]
M3      DD      ?                      ; x[n-3]
MC      DD      ?                      ; Carry (aligned)
IM      DD      ?                      ; index into state buffer
Instset DD      ?                      ; Instruction set
        DD      ?                      ; unused filler
MF0     DD      ?                      ; 5115 (aligned)
        DD      ?                      ; unused filler
MF2     DD      ?                      ; 1492
        DD      ?                      ; unused filler
MF1     DD      ?                      ; 1776 (aligned)
        DD      ?                      ; unused filler
MF3     DD      ?                      ; 2111111111
        DD      ?                      ; unused filler
one     DQ      ?                      ; 1.0 (aligned)
temp    DQ      ?                      ; temporary storage of float
CRandomMotherA ENDS

MOTHERF0 EQU 5115                      ; factor 0
MOTHERF1 EQU 1776                      ; factor 1
MOTHERF2 EQU 1492                      ; factor 2
MOTHERF3 EQU 2111111111                ; factor 3


; ***************************************************************************
; Definitions for SFMT generator
; ***************************************************************************

; Choose Mersenne exponent.
; Higher values give longer cycle length and use more memory:
; MEXP equ    607
; MEXP equ   1279
; MEXP equ   2281
; MEXP equ   4253
  MEXP equ  11213
; MEXP equ  19937
; MEXP equ  44497

IF MEXP eq 44497
SFMT_N      equ  348      ; Size of state vector
SFMT_M      equ  330      ; Position of intermediate feedback
SFMT_SL1    equ    5      ; Left shift of W[N-1], 32-bit words
SFMT_SL2    equ    3      ; Left shift of W[0], *8, 128-bit words
SFMT_SR1    equ    9      ; Right shift of W[M], 32-bit words
SFMT_SR2    equ	   3      ; Right shift of W[N-2], *8, 128-bit words
SFMT_MASK1  equ  0effffffbH  ;first DWORD of AND mask
SFMT_MASK   textequ <0effffffbH,0dfbebfffH,0bfbf7befH,09ffd7bffH> ; AND mask
SFMT_PARITY textequ <1,0,0a3ac4000H,0ecc1327aH> ; Period certification vector

ELSEIF MEXP eq 19937
SFMT_N      equ  156      ; Size of state vector
SFMT_M      equ  122      ; Position of intermediate feedback
SFMT_SL1    equ   18      ; Left shift of W[N-1], 32-bit words
SFMT_SL2    equ    1      ; Left shift of W[0], *8, 128-bit words
SFMT_SR1    equ   11      ; Right shift of W[M], 32-bit words
SFMT_SR2    equ	   1      ; Right shift of W[N-2], *8, 128-bit words
SFMT_MASK1  equ  0dfffffefH  ;first DWORD of AND mask
SFMT_MASK   textequ <0dfffffefH,0ddfecb7fH,0bffaffffH,0bffffff6H> ; AND mask
SFMT_PARITY textequ <1,0,0,013c9e684H> ; Period certification vector

ELSEIF MEXP eq 11213
SFMT_N      equ  88     ; Size of state vector
SFMT_M      equ  68     ; Position of intermediate feedback
SFMT_SL1	equ  14     ; Left shift of W[N-1], 32-bit words
SFMT_SL2	equ   3     ; Left shift of W[0], *8, 128-bit words
SFMT_SR1	equ   7     ; Right shift of W[M], 32-bit words
SFMT_SR2	equ   3     ; Right shift of W[N-2], *8, 128-bit words
SFMT_MASK1  equ  0effff7fbH  ;first DWORD of AND mask
SFMT_MASK	textequ <0effff7fbH,0ffffffefH,0dfdfbfffH,07fffdbfdH> ; AND mask
SFMT_PARITY textequ <1,0,0e8148000H,0d0c7afa3H > ; Period certification vector

ELSEIF MEXP eq 4253
SFMT_N      equ  34     ; Size of state vector
SFMT_M      equ  17     ; Position of intermediate feedback
SFMT_SL1	equ  20     ; Left shift of W[N-1], 32-bit words
SFMT_SL2	equ  1      ; Left shift of W[0], *8, 128-bit words
SFMT_SR1	equ  7      ; Right shift of W[M], 32-bit words
SFMT_SR2	equ  1      ; Right shift of W[N-2], *8, 128-bit words
SFMT_MASK1  equ  09f7bffffH  ;first DWORD of AND mask
SFMT_MASK	textequ <09f7bffffH,09fffff5fH,03efffffbH,0fffff7bbH> ; AND mask
SFMT_PARITY textequ <0a8000001H,0af5390a3H,0b740b3f8H,06c11486dH> ; Period certification vector

ELSEIF MEXP eq 2281
SFMT_N      equ  18     ; Size of state vector
SFMT_M      equ  12     ; Position of intermediate feedback
SFMT_SL1	equ  19     ; Left shift of W[N-1], 32-bit words
SFMT_SL2	equ   1     ; Left shift of W[0], *8, 128-bit words
SFMT_SR1	equ   5     ; Right shift of W[M], 32-bit words
SFMT_SR2	equ   1     ; Right shift of W[N-2], *8, 128-bit words
SFMT_MASK1  equ   0bff7ffbfH ;first DWORD of AND mask
SFMT_MASK	textequ <0bff7ffbfH,0fdfffffeH,0f7ffef7fH,0f2f7cbbfH> ; AND mask
SFMT_PARITY textequ <1,0,0,041dfa600H> ; Period certification vector

ELSEIF MEXP eq 1279
SFMT_N      equ  10     ; Size of state vector
SFMT_M      equ   7     ; Position of intermediate feedback
SFMT_SL1	equ  14     ; Left shift of W[N-1], 32-bit words
SFMT_SL2	equ   3     ; Left shift of W[0], *8, 128-bit words
SFMT_SR1	equ   5     ; Right shift of W[M], 32-bit words
SFMT_SR2	equ   1     ; Right shift of W[N-2], *8, 128-bit words
SFMT_MASK1  equ   0f7fefffdH ;first DWORD of AND mask
SFMT_MASK	textequ <0f7fefffdH,07fefcfffH,0aff3ef3fH,0b5ffff7fH> ; AND mask
SFMT_PARITY textequ <1,0,0,020000000H> ; Period certification vector

ELSEIF MEXP eq 607
SFMT_N      equ   5     ; Size of state vector
SFMT_M      equ   2     ; Position of intermediate feedback
SFMT_SL1	equ  15     ; Left shift of W[N-1], 32-bit words
SFMT_SL2	equ   3     ; Left shift of W[0], *8, 128-bit words
SFMT_SR1	equ  13     ; Right shift of W[M], 32-bit words
SFMT_SR2	equ   3     ; Right shift of W[N-2], *8, 128-bit words
SFMT_MASK1  equ   0fdff37ffH ;first DWORD of AND mask
SFMT_MASK	textequ <0fdff37ffH,0ef7f3f7dH,0ff777b7dH,07ff7fb2fH> ; AND mask
SFMT_PARITY textequ <1,0,0,05986f054H> ; Period certification vector

ELSE
.ERR  <MEXP must have one of the predefined values>
ENDIF


CRandomSFMTA STRUC
Fill         DD      4 dup (?)         ; Alignment filler

; Parameters for Mother-Of-All generator:
M3           DD      ?                      ; x[n-3] (aligned)
             DD      ?                      ; unused filler to fit the pmuludq instruction
M2           DD      ?                      ; x[n-2]
             DD      ?                      ; unused filler to fit the pmuludq instruction
M1           DD      ?                      ; x[n-1]
             DD      ?                      ; unused filler to fit the pmuludq instruction
M0           DD      ?                      ; x[n]
MC           DD      ?                      ; Carry (zero-extends into one)
one          DQ      ?                      ; 1.0 (low dword = zero-extension of carry) (aligned)
TempRan      DQ      ?                      ; Temporary random number
MF3          DD      ?                      ; 2111111111 (aligned)
Instset      DD      ?                      ; Instruction set
MF2          DD      ?                      ; 1492 (MF3,MF2,MF1,MF0 interleaved with other variables to fit the pmuludq instruction)
             DD      ?                      ; Filler (may be used for read-only parameter, but not for read/write parameter)
MF1          DD      ?                      ; 1776
             DD      ?                      ; Filler (may be used for read-only parameter, but not for read/write parameter)
MF0          DD      ?                      ; 5115
             DD      ?                      ; Filler (may be used for read-only parameter, but not for read/write parameter)

; Parameters for IRandomX:
LASTINTERVAL DD      ?                      ; Last interval length for IRandomX
RLIMIT       DD      ?                      ; Rejection limit used by IRandomX

; Parameters for SFMT generator:
USEMOTHER    DD      ?                      ; 1 if combine with Mother-Of-All generator
IX           DD      ?                      ; Index into state buffer for SFMT

AMASK        DD      4 dup (?)              ; AND mask (aligned)
STATE        DD  SFMT_N*4 dup (?)           ; State vector (aligned)
CRandomSFMTA ENDS
