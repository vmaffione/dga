#ifndef GENETIC_ALGORITHM_
#define GENETIC_ALGORITHM_

#include <iostream>
#include <typeinfo>  // for RTTI
#include <vector>
#include <string>
#include <math.h>
#include <string.h>


using namespace std; // per colpa dell'operatore ostream& operator<< di IT

#include "pga_error.h"
#include "pga_utils.h"

#define DEBUG 0


/************************** MAIN CLASS DECLARATION ****************************/

template <class IT, class OT>
class GeneticAlgorithm
  { 
    private:
      typedef OT ( *FitnessFunctionPT )( const IT& );
      FitnessFunctionPT fitnessFunctionPointer;
      
      typedef void ( *MutationFunctionPT )( const IT&, IT& );
      MutationFunctionPT mutationFunctionPointer;
      GAUtils::MutationFunctionType mutationFunctionType;
      
      typedef void ( *CrossoverFunctionPT )( const IT&, const IT&, IT& );
      CrossoverFunctionPT crossoverFunctionPointer;
      
      typedef void ( GAUtils::* MutationFunctionPTTM )( const IT&, IT& );
      MutationFunctionPTTM mutationFunctionPointerTM;
      
      typedef void ( GAUtils::* CrossoverFunctionPTTM )( const IT&, const IT&, IT& );
      CrossoverFunctionPTTM crossoverFunctionPointerTM;
      
      void demultiplexCrossoverType( GAUtils::CrossoverFunctionType cft );
      void demultiplexMutationType( GAUtils::MutationFunctionType mft );
      
      struct IndividualInfo  // data structure corresponding to an individual
        {
          IT* pointer;
          OT score;
        };
      
      IT* population;   //  array which contains the individuals of the current population
      IT* nextPopulation;  // array built gradually, stores the new individuals
      IT** selectedParents;  // array of pointers to the individuals selected for reproduction
      
      class InfoHeap  // max-binary-heap class used to store the scores of individuals
        {
            int N;
          public:
            IndividualInfo* heapArray;  // array implementing the binary-heap 
            
            InfoHeap( int n );    // only used with n == 0
            void reinit( int n );  // used to reinitialize the heap
            
            int lastNode;  // current index of the last element in the heap
            // void reset() { lastNode = -1; }  // makes the heap empty
            void insert( IndividualInfo );  // insert an element into the heap
            void sortLocally();  //  sort the array heapArray using heap-sort
            void print() const;
        };
      InfoHeap infoHeap; // binary-heap structure which contains a data structure for each individual of the current population
      
      void commonConstructor( const vector<int>& path );
      
      int N;     // number of individuals of array population
      int NCC;   // number of crossover children (i.e. children generated by crossover)
      int NMC;   // number of mutation children (i.e. children generated by mutation)
      int NEC;   // number of elite children (i.e. children)
      float CF;  // crossover fraction
      int P;     // number of parents required to compute next generation
      int CP;    // number of parents required to compute next generation by recombination
      float MF;    // migration fraction: fraction of the individual that are propagated during migration rounds
      int MI;    // migration interval: number of GA iteration between two migration rounds
      
      int maxGenerations; // maximum number of iterations of the algorithm
      
      
      int prev, succ;
      enum NodeColor { RED = 0, BLACK };
      NodeColor myColor;
      
      
      GAUtils::SelectionFunctionType SFType;
      
      double scalingCoeff;
      void performFitnessScaling(); // MATLAB rankScaling
      
      void performParentsSelection();  // chooses P individuals from the current population
        void stochasticUniversalSampling();
      
      void shuffleParents();  // shuffles selected parents
      
      void gaCore();
      
      bool isOutputTypeValid( const char* t ) const;
      bool continuousOptimization( const char* t ) const;
    public:
      GeneticAlgorithm( FitnessFunctionPT ffpt, MutationFunctionPT mfpt, CrossoverFunctionPT cfpt, GAUtils::SelectionFunctionType sft, const vector<int>& path );
      GeneticAlgorithm( FitnessFunctionPT ffpt, MutationFunctionPT mfpt, GAUtils::CrossoverFunctionType cft, GAUtils::SelectionFunctionType sft, const vector<int>& path );
      GeneticAlgorithm( FitnessFunctionPT ffpt, GAUtils::MutationFunctionType mft, CrossoverFunctionPT cfpt, GAUtils::SelectionFunctionType sft, const vector<int>& path );
      GeneticAlgorithm( FitnessFunctionPT ffpt, GAUtils::MutationFunctionType mft, GAUtils::CrossoverFunctionType cft, GAUtils::SelectionFunctionType sft, const vector<int>& path );
      
      void run( const std::vector<IT>& initialPopulation, int maxGen, float cf, int eliteChildren, float mf, int mi ); // run the genetic algorithm with a user-provided initial population
      
      GAUtils gaUtils;  // allows to generate random initial populations
  };




/******************************************************************************/
/*                      GeneticAlgorithm class implementation                 */
/******************************************************************************/

template <class IT, class OT>
bool GeneticAlgorithm<IT,OT>::isOutputTypeValid( const char* t ) const
  {
    if ( strcmp( t, typeid( float ).name() ) == 0 )
      return true;
    else if ( strcmp( t, typeid( double ).name() ) == 0 )
      return true;
    else if ( strcmp( t, typeid( int ).name() ) == 0 )
      return true;
    else if ( strcmp( t, typeid( long int ).name() ) == 0 )
      return true;
    else if ( strcmp( t, typeid( short int ).name() ) == 0 )
      return true;
    return false;
  }


template <class IT, class OT>
bool GeneticAlgorithm<IT,OT>::continuousOptimization( const char* t ) const
  {
    if ( strcmp( t, typeid( FloatVector ).name() ) == 0 )
      return true;
    if ( strcmp( t, typeid( DoubleVector ).name() ) == 0 )
      return true;
    if ( strcmp( t, typeid( float ).name() ) == 0 )
      return true;
    if ( strcmp( t, typeid( double ).name() ) == 0 )
      return true;
    return false;
  }

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::demultiplexCrossoverType( GAUtils::CrossoverFunctionType cft )
  {
    switch ( cft )
      {
        case GAUtils::CrossoverConvex:
          if ( continuousOptimization( typeid( IT ).name() ) )
            crossoverFunctionPointerTM = &GAUtils::crossoverConvex<IT>; 
          else
            throw GAError( "You can't use convex crossover with this input type" );
        break;
        
        case GAUtils::CrossoverScattered:
          if ( continuousOptimization( typeid( IT ).name() ) )
            crossoverFunctionPointerTM = &GAUtils::crossoverScattered<IT>;
          else
            throw GAError( "You can't use scattered crossover with this input type" );
          break;
        
        default:
          throw GAError( "Invalid operator function identificator" );
      }
  }

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::demultiplexMutationType( GAUtils::MutationFunctionType mft )
  {
    switch ( mft )
      {
        case GAUtils::MutationGaussian:
          if ( continuousOptimization( typeid( IT ).name() ) )
            mutationFunctionPointerTM = &GAUtils::mutationGaussian<IT>;
          else
            throw GAError( "You can't use gaussian mutation with this input type" );
        break;

        default:
          throw GAError( "Invalid mutation operator identificator" );
      }
  }

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::commonConstructor( const vector<int>& path )
  {
    // Input checking
    if ( !isOutputTypeValid( typeid( OT ).name() ) )
      throw GAError( "Bad output type" );
    
    // the following parameters will be initialized just before running the algorithm
    N = 0;
    maxGenerations = -1; CF = -1.0; NEC = -1; MF = -1.0; MI = -1;
    
    // USE PATH HERE
    
  }

// user provided mutation function and crossover functon
template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm( FitnessFunctionPT ffpt, MutationFunctionPT mfpt, CrossoverFunctionPT cfpt, GAUtils::SelectionFunctionType sft, const vector<int>& path ) : fitnessFunctionPointer( ffpt ), mutationFunctionPointer( mfpt ), mutationFunctionPointerTM( NULL ), crossoverFunctionPointer( cfpt ), crossoverFunctionPointerTM( NULL ), SFType( sft ), infoHeap( 0 ), population( NULL ), nextPopulation( NULL ), selectedParents( NULL )
  {
    commonConstructor( path );
    std::cout << "A genetic algorithm object was generated!\n";
  }

// user provided mutation function and library local crossover functon
template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm( FitnessFunctionPT ffpt, MutationFunctionPT mfpt, GAUtils::CrossoverFunctionType cft, GAUtils::SelectionFunctionType sft, const vector<int>& path ) : fitnessFunctionPointer( ffpt ), mutationFunctionPointer( mfpt ), mutationFunctionPointerTM( NULL ), crossoverFunctionPointer( NULL ), SFType( sft ), infoHeap( 0 ), population( NULL ), nextPopulation( NULL ), selectedParents( NULL )
{
    commonConstructor( path );
    // demultiplexing crossover function enumeration
    demultiplexCrossoverType( cft );
    std::cout << "A genetic algorithm object was generated!\n";
  }
  
// library local mutation function and user provided crossover functon
template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm( FitnessFunctionPT ffpt, GAUtils::MutationFunctionType mft, CrossoverFunctionPT cfpt, GAUtils::SelectionFunctionType sft, const vector<int>& path ) : fitnessFunctionPointer( ffpt ), mutationFunctionPointer( NULL ), mutationFunctionType( mft ), crossoverFunctionPointer( cfpt ), crossoverFunctionPointerTM( NULL ), SFType( sft ), infoHeap( 0 ), population( NULL ), nextPopulation( NULL ), selectedParents( NULL )
{
    commonConstructor( path );
    // demultiplexing mutation function enumeration
    demultiplexMutationType( mft );
    std::cout << "A genetic algorithm object was generated!\n";
  }



// library local mutation function and crossover functon
template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm( FitnessFunctionPT ffpt, GAUtils::MutationFunctionType mft, GAUtils::CrossoverFunctionType cft, GAUtils::SelectionFunctionType sft, const vector<int>& path ) : fitnessFunctionPointer( ffpt ), mutationFunctionPointer( NULL ), mutationFunctionType( mft ), crossoverFunctionPointer( NULL ), SFType( sft ), infoHeap( 0 ), population( NULL ), nextPopulation( NULL ), selectedParents( NULL )
  {
    commonConstructor( path );
    // demultiplexing crossover function enumeration
    demultiplexCrossoverType( cft );
    // demultiplexing mutation function enumeration
    demultiplexMutationType( mft );
    std::cout << "A genetic algorithm object was generated!\n";
  }

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::performFitnessScaling()
  {
    for ( int i=0; i<N; i++ )
      infoHeap.heapArray[i].score = scalingCoeff / sqrt( i + 1 );
  }

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::stochasticUniversalSampling()
  {
  	/* --- stochastic universal sampling --- */
	int i = P;                   /* number of individuals to select */
	int j = N;                   /* population size*/
	float sum = 0;               /* sum of relative fitness values (cumulative fitness value) */
	float mark, inc;             /* marker position and increment */

	inc  = 1.0; // inc = P/P;    /* P markers on wheel with a circumference of length P */
	mark = inc * rand_float();         /* choose position of first marker */
	while ( (--j >= 0) && (i > 0) )  /* traverse the population */
	{   
	  sum += infoHeap.heapArray[j].score;     /* compute end of wheel section */
	  while (mark < sum)        /* while next marker is in the section */
		{     
		  selectedParents[--i] = infoHeap.heapArray[j].pointer; /* select the individual */
		  mark += inc; 
		}
	}                        
	while (--i >= 0)                                       /* if not enough individuals selected, */
	  selectedParents[i] = infoHeap.heapArray[0].pointer;  /* fill with first individual (the best one) */
	/*----------------------------------------------------------------------
	The check for (i > 0) in the outer while loop as well as the loop that
	fills the vector of selected individuals are needed due to possible
	roundoff errors in the fitness computations, which may cause too many
	or too few individuals getting selected.
	----------------------------------------------------------------------*/
  } 


template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::performParentsSelection()
  {
    switch ( SFType )
      {
        case GAUtils::SUS:  // Stochastic universal sampling
            stochasticUniversalSampling();
          break;
        case GAUtils::RWS:
          throw GAError( "RWS not yet implemented" );
          break;
      }
    //for ( int i=0; i<P; i++ ) cout << *(selectedParents[i]) << ", "; cout << "\n";
  }
  
template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::shuffleParents()
  {
    // shuffle array selectedParents implementing Fisher–Yates method (Durstenfeld version)
    for ( int i=P-1; i>0; i-- )
      {
        int j = rand_int( 0, i );  // generate a random integer number between 0 and i (included)
        IT* tmp = selectedParents[i];
        selectedParents[i] = selectedParents[j];
        selectedParents[j] = tmp;
      }
  }


// GA engine
template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::gaCore()
  {                                   
    // evaluates fitness on the initial population
    IndividualInfo info;
    for ( int i=0; i<N; i++ )
	  {	
		// builds an "IndividualInfo" and inserts it into the heap
		info.pointer = &population[i];
		info.score = ( *fitnessFunctionPointer )( population[i] ); 
		infoHeap.insert( info );
	  }
  
    rand_init();   // initializes random generator
  
    int numGenerations = 1;
    int migrationCountdown = MI;
    for ( ;; )  // main cycle  
      {
        
        if ( DEBUG ) {  
        cout << "Generazione " << numGenerations << ":\n";
        for ( int i=0; i<N; i++ )
          {
            cout << population[i] << ", score = " << ( ( *fitnessFunctionPointer )( population[i] ) ) << "\n";
          } cout << "ScaleV = "; for ( int i=0;i<gaUtils.D; i++ ) cout << gaUtils.mgScaleV[i] << " "; cout << "\n\n"; system("PAUSE"); }
          
          
		infoHeap.sortLocally();  // sorts population by scaled scores

        if ( migrationCountdown == 0 )
          {
            migrationCountdown = MI;
            // mutation round
            // estrae mf dall'heap e li ricevedall'altro
          }
        



		performFitnessScaling();   // scales raw fitnesses  

        //cout << "Generation # " << numGenerations << "\n";
		//for ( int i=0; i<N; i++ ) cout << *(infoHeap.heapArray[i].pointer) << " "; cout << "\n\n";

		//infoHeap.print();system("PAUSE");

		performParentsSelection();  // selects parents for reproduction

		/* crossover function are designed in such a way that only parents which are
		   consecutive in the array "selectedParents" are going to mating; moreover,
		   crossover is performed only over the elements [0:CP-1], while mutation is
		   performed on the elements [CP:P-1]; for these reasons at this point we
		   have to shuffle the array by generating a random permutation */
		shuffleParents();

		// generate the elite children copying the best individuals of the current population
        for ( int i=0; i<NEC; i++ )
          nextPopulation[i] = *( infoHeap.heapArray[i].pointer );
        
        // performs crossover and stores resulting children in nextPopulation[0:NCC-1]
        if ( crossoverFunctionPointer != NULL ) // calls user provided (global) function
          for ( int i=NEC, spi=0; i<NEC+NCC; i++, spi+=2 )
            ( *crossoverFunctionPointer )( *( selectedParents[ spi ] ), *( selectedParents[ spi+1 ] ), nextPopulation[i] );
        else  // calls GAUtils member function, by deferentiating the pointer to member
          for ( int i=NEC, spi=0; i<NEC+NCC; i++, spi+=2 )
            ( gaUtils.*crossoverFunctionPointerTM )( *( selectedParents[ spi ] ), *( selectedParents[ spi+1 ] ), nextPopulation[i] );
        
        
        
        // performs mutation and stores resulting children in nextPopulation[NCC:N-1]
        if ( mutationFunctionPointer != NULL ) // calls user provided (global) function
          for ( int i=NEC+NCC, spi=CP; i<N; i++, spi++ )
            ( *mutationFunctionPointer )( *( selectedParents[ spi ] ), nextPopulation[i] );
        else  // calls GAUtils member function, by deferentiating the pointer to member
          {
            for ( int i=NEC+NCC, spi=CP; i<N; i++, spi++ )
              ( gaUtils.*mutationFunctionPointerTM )( *( selectedParents[ spi ] ), nextPopulation[i] );
            
            if ( mutationFunctionType == GAUtils::MutationGaussian )  // refresh mutationGaussian parameters
              {              
                for ( int i=0; i<gaUtils.D; i++ )
                  gaUtils.mgScaleV[i] *= 1 - ( gaUtils.shrink * numGenerations ) / maxGenerations;
              }
          }
        
		// swap current and next generation
		IT* tmp = population;
		population = nextPopulation;
		nextPopulation = tmp;
        
       /*
       for ( int i=0; i<N; i++ )
      {
        for ( int d=0; d<D; d++ )
          cout << population[i][d] << ", ";
        cout << "\n";
      }cout << "\n";system("PAUSE");*/
       
       
        
        // evaluates fitness on the new population
        IndividualInfo info;
        for ( int i=0; i<N; i++ )
		  {	
			// builds an "IndividualInfo" and inserts it into the heap
			info.pointer = &population[i];
			info.score = ( *fitnessFunctionPointer )( population[i] ); 
			infoHeap.insert( info );
		  }
        
        numGenerations++;
        if ( numGenerations == maxGenerations )
          break;
        migrationCountdown--;
      }
      
      cout << "Optimization terminated! Best results:\n";
      for ( int i=0; i<( (N>10) ? 10 : N ); i++ ) cout << "(" << i+1 << ") " << *(infoHeap.heapArray[i].pointer) << ", score " << infoHeap.heapArray[i].score << "\n"; cout << "\n";
  }


template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::run( const std::vector<IT>& initialPopulation, int maxGen = 100, float cf = 0.8, int eliteChildren = 3, float mf = 0.1, int mi = 20 )
  { 
     if ( initialPopulation.size() == 0 )
      throw GAError( "GA.run: population provided is empty" );
  
    
    bool memOptionsChanged = false;
    // refresh options which require memory allocation only if suitable
    maxGenerations = maxGen;
    if ( cf != CF && cf >= 0.0 && cf <= 1.0 )
      {
        CF = cf;
        memOptionsChanged = true;
      }
    if ( eliteChildren != NEC && eliteChildren >= 0 && eliteChildren <= initialPopulation.size() )
      {
        NEC = eliteChildren;
        memOptionsChanged = true;
      }
    if ( mf != MF && mf >= 0.0 and mf <=1.0 )
      {
        MF = mf;
        // MODIFICHE CHE COMPORTANO ALLOCAZIONI??
      }
    MI = mi;
    
    // initializes class GeneticAlgorithm
    if ( initialPopulation.size() != N )  // allocates memory and refreshes options only if necessary
      {
        N = initialPopulation.size();
        
        if ( population != NULL )
          {
            delete [] population;
            delete [] nextPopulation;
          }
        
        
        //cout << "Parameters: " <<  CF << ", " << NEC << ", " << maxGenerations << "\n";
        population = new IT[ N ];      // IT default constructor
        nextPopulation = new IT[ N ];  // IT default constructor
        infoHeap.reinit( N );

        memOptionsChanged = true;
        /*
    if ( D < 1 )
      throw GAError( "Bad input dimension" );
    if ( 3 > 1 && !isMultidimensionalInput( typeid( IT ).name() ) )
      throw GAError( "You can't specify input dimension" ); */
    
    // manages multi-dimensional input initialization
    //multiDimInit<IT>( D, N, population, nextPopulation );        
      }
    
    
    if ( memOptionsChanged )  // da raffinare!!
      {
         // initialize population parameters
         NCC = static_cast<int>( CF * ( N - NEC ) );
         NMC = N - NEC - NCC;
         // two parents for each crossover-generated child and one parent for each mutation generated child
         CP =  2 * NCC;
         P = CP + NMC;
         
         delete [] selectedParents;
         selectedParents = new IT*[ P ];
    
         // compute scaling coefficient (fitness scaling)
         scalingCoeff = 0.0;
         for ( int i=1; i<=N; i++ )
           scalingCoeff += 1/sqrt(i);
         scalingCoeff = ( P ) / scalingCoeff;
      }
    
    cout << "here!\n";
    
    for ( int i=0; i<N; i++ )
      {
        population[i] = initialPopulation[i];  /* IT assignment operator, which is assumed to allocate memory (so nextPopulation is initialized) */
        nextPopulation[i] = initialPopulation[i];
      }
      
    cout << "Starting optimization...!\n";  
    gaCore();
  }





/* ---------------------------------------------------------------------------*/
/*                    InfoHeap class implementation                           */
/* ---------------------------------------------------------------------------*/

// not used at the moment
template <class IT, class OT>
GeneticAlgorithm<IT,OT>::InfoHeap::InfoHeap( int n ) : lastNode( -1 ), N( n )
  {
    if ( n > 0 )
      heapArray = new IndividualInfo[ n + 1 ];  // the last position is reserved and used as a "swap area"
// else do nothing
  }

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::reinit( int n )
  {
    if ( n <= 0 )
      throw GAError( " InfoHeap.init( n ): n must be > 0 " );
    if ( N != n ) // deallocates and reallocates only if necessary
      {
        if ( N ) 
          delete [] heapArray;
        N = n;
        lastNode = -1;
        heapArray = new IndividualInfo[ N + 1 ];  // the last position is reserved and used as a "swap area"
      }
  }

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::insert( IndividualInfo element )  /// ( const IndividualInfo& element )     ?????
  {
    //cout << "heap last position = " << lastNode+1 << "\n";
    if ( lastNode == N-1 )
      throw GAError( "Da qualche parte c'è un bug: lo heap non deve andare in overflow" );
    heapArray[ ++lastNode ] = element;
    // execute the "up" procedure iteratively
    int currentIndex = lastNode, parentIndex;
    for ( ;; )
      {
        parentIndex = ( currentIndex - 1 ) / 2;
        if ( heapArray[ currentIndex ].score > heapArray[ parentIndex ].score )
          {
            // swaps using the "swap area"
            heapArray[ N ] = heapArray[ currentIndex ];
            heapArray[ currentIndex ] = heapArray[ parentIndex ];
            heapArray[ parentIndex ] = heapArray[ N ];
            currentIndex = parentIndex;
          }
        else 
          break;
      }
  }

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::sortLocally()
  {      
    while ( lastNode )
      { 
        // swap the root with the current actual position 
  		heapArray[ N ] = heapArray[ 0 ];
		heapArray[ 0 ] = heapArray[ lastNode ];
		heapArray[ lastNode-- ] = heapArray[ N ];
		
		// execute the "down" procedure iteratively
		int currentIndex = 0, sonIndex;
		for ( ;; )
		  {
			sonIndex = 2 * currentIndex + 1;
			if ( sonIndex == lastNode )
			  {
				if ( heapArray[ sonIndex ].score > heapArray[ currentIndex ].score )
				  {
					heapArray[ N ] = heapArray[ currentIndex ];
					heapArray[ currentIndex ] = heapArray[ sonIndex ];
					heapArray[ sonIndex ] = heapArray[ N ];
				  }
				break;
			  }
			else if ( sonIndex < lastNode )
			  {
				if ( heapArray[ sonIndex + 1 ].score > heapArray[ sonIndex ].score )
				  sonIndex++;
				if ( heapArray[ sonIndex ].score > heapArray[ currentIndex ].score )
				  {
					heapArray[ N ] = heapArray[ currentIndex ];
					heapArray[ currentIndex ] = heapArray[ sonIndex ];
					heapArray[ sonIndex ] = heapArray[ N ];
					currentIndex = sonIndex;
				  } 
			    else break;
			  }
			else
			  break;  
		  }  
        }
    lastNode = -1;
  }

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::print() const
  {
    for ( int i=0; i<N; i++ )
      std::cout << "Individual: " << ( *( heapArray[i].pointer ) ) << ", score = " << heapArray[i].score << "\n";
  }



#endif
