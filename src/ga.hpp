#ifndef GENETIC_ALGORITHM_
#define GENETIC_ALGORITHM_

#include <iostream>
#include <typeinfo>  // for RTTI
#include <vector>
#include <string>
#include <cmath>
#include <cstring>
#include <stdint.h>
#include <pthread.h>


using namespace std; // per colpa dell'operatore ostream& operator<< di IT

#include "ga-error.hpp"
#include "ga-utils.hpp"
#include "peer-server.hpp"

#define DEBUG 0


class GAReceiveBuffer {
        pthread_mutex_t lock_;

    public:
        uint8_t *ptr;
        unsigned int size;
        unsigned int len;

        GAReceiveBuffer(unsigned int sz);
        ~GAReceiveBuffer();
        void lock();
        void unlock();
};

#define MIGRATE_MSG_ID  95

class MigrationMsg : public Message {
    public:
        uint8_t *buf;
        unsigned int len;

        MigrationMsg() : buf(NULL), len(0) { }
        MigrationMsg(uint8_t *b, unsigned int l) : buf(b), len(l) { }

        int serialize(RemoteConnection& remote) const;
        int deserialize(RemoteConnection& remote);
};

class GAPeerServer : public PeerServer {
        GAReceiveBuffer *recvbuf;

    public:
        GAPeerServer(unsigned int s_port, unsigned int j_port);
        int process_message(uint8_t opcode,
                                    RemoteConnection& connection);
        void set_receive_buffer(GAReceiveBuffer *b);
};

/************************** MAIN CLASS DECLARATION **************************/

template <class IT, class OT>
class GeneticAlgorithm
{
    private:
        typedef OT (*FitnessFunctionPT)(const IT&);
        FitnessFunctionPT fitnessFunctionPointer;

        typedef void (*MutationFunctionPT)(const IT&, IT&);
        MutationFunctionPT mutationFunctionPointer;
        GAUtils::MutationFunctionType mutationFunctionType;

        typedef void (*CrossoverFunctionPT)(const IT&, const IT&, IT&);
        CrossoverFunctionPT crossoverFunctionPointer;

        typedef void (GAUtils::* MutationFunctionPTTM)(const IT&, IT&);
        MutationFunctionPTTM mutationFunctionPointerTM;

        typedef void (GAUtils::* CrossoverFunctionPTTM)(const IT&, const IT&,
                                                        IT&);
        CrossoverFunctionPTTM crossoverFunctionPointerTM;

        void demultiplexCrossoverType(GAUtils::CrossoverFunctionType cft);
        void demultiplexMutationType(GAUtils::MutationFunctionType mft);

        /* Data structure corresponding to an individual. */
        struct IndividualInfo
        {
            IT* pointer;
            OT score;
        };

        /* Array which contains the individuals of the current population */
        IT* population;

        /* Array built gradually, stores the new individuals. */
        IT* nextPopulation;

        /* Array of pointers to the individuals selected for reproduction. */
        IT** selectedParents;

        /* Max-binary-heap class used to store the scores of individuals. */
        class InfoHeap
        {
                unsigned int N;
            public:
                /* Array implementing the binary-heap. */
                IndividualInfo* heapArray;

                InfoHeap(unsigned int n);        /* Only used with n == 0 */
                void reinit(unsigned int n);     /* Used to reinitialize the heap. */

                /* Current index of the last element in the heap. */
                int lastNode;

                /* Makes the heap empty. */
                void reset() { lastNode = -1; }

                /* Insert an element into the heap. */
                void insert(IndividualInfo);

                /* Sort the array heapArray using heap-sort */
                void sortLocally();
                void print() const;
                unsigned int size() const { return (lastNode + 1); }
        };

        /* Binary-heap structure which contains a data structure for each
           individual of the current population. */
        InfoHeap infoHeap;

        void commonConstructor();

        /* Number of individuals of array population. */
        unsigned int N;

        /* Number of crossover children (i.e. children generated by
           crossover). */
        unsigned int NCC;

        /* Number of mutation children (i.e. children generated by
           mutation). */
        unsigned int NMC;

        /* Number of elite children. */
        unsigned int NEC;

        /* Crossover fraction */
        float CF;

        /* Number of parents required to compute next generation. */
        unsigned int P;

        /* Number of parents required to compute next generation by
           recombination. */
        unsigned int CP;

        /* Migration fraction: fraction of the individual that are propagated
           during migration rounds */
        float MF;

        /* Migration period: number of GA iteration between two migration
           rounds. */
        unsigned int MP;

        /* Number of migration individuals: number of individuals of the
           current population which migrate away. */
        unsigned int NMI;

        /* Maximum number of iterations of the algorithm. */
        unsigned int maxGenerations;

        static const int GA_BASE_SEED = 961114537;
        static const int GA_MUL_SEED = 113;

        uint8_t* sendBuffer;
        GAReceiveBuffer *receiveBuffer;
        IT** pointersBuffer;
        OT* receivedIndividualsScores;

        GAUtils::SelectionFunctionType SFType;

        double scalingCoeff;

        GAPeerServer& server;

        /* MATLAB rankScaling */
        void performFitnessScaling();

        /* Chooses P individuals from the current population. */
        void performParentsSelection();
        void stochasticUniversalSampling();

        /* Shuffles selected parents. */
        void shuffleParents();

        void gaCore();

        void gatherResults();

        bool isOutputTypeValid(const char* t) const;
        bool continuousOptimization(const char* t) const;
    public:
        GeneticAlgorithm(FitnessFunctionPT ffpt, MutationFunctionPT mfpt,
                         CrossoverFunctionPT cfpt,
                         GAUtils::SelectionFunctionType sft,
                        GAPeerServer& server);
        GeneticAlgorithm(FitnessFunctionPT ffpt, MutationFunctionPT mfpt,
                         GAUtils::CrossoverFunctionType cft,
                         GAUtils::SelectionFunctionType sft,
                        GAPeerServer& server);
        GeneticAlgorithm(FitnessFunctionPT ffpt,
                         GAUtils::MutationFunctionType mft,
                         CrossoverFunctionPT cfpt,
                         GAUtils::SelectionFunctionType sft,
                        GAPeerServer& server);
        GeneticAlgorithm(FitnessFunctionPT ffpt,
                         GAUtils::MutationFunctionType mft,
                         GAUtils::CrossoverFunctionType cft,
                         GAUtils::SelectionFunctionType sft,
                        GAPeerServer& server);

        /* Run the genetic algorithm with a user-provided initial
           population. */
        void run(const std::vector<IT>& initialPopulation, unsigned int maxGen = 100,
                 float cf = 0.8, unsigned int eliteChildren = 3, float mf = 0.1,
                 unsigned int mi = 20);

        /* Allows to generate random initial populations. */
        GAUtils gaUtils;
};




/***************************************************************************/
/*                      GeneticAlgorithm class implementation              */
/***************************************************************************/

template <class IT, class OT>
bool GeneticAlgorithm<IT,OT>::isOutputTypeValid(const char* t) const
{
    if (strcmp(t, typeid(float).name()) == 0)
        return true;
    else if (strcmp(t, typeid(double).name()) == 0)
        return true;
    else if (strcmp(t, typeid(int).name()) == 0)
        return true;
    else if (strcmp(t, typeid(long int).name()) == 0)
        return true;
    else if (strcmp(t, typeid(short int).name()) == 0)
        return true;
    return false;
}


template <class IT, class OT>
bool GeneticAlgorithm<IT,OT>::continuousOptimization(const char* t) const
{
    if (strcmp(t, typeid(FloatVector).name()) == 0)
        return true;
    if (strcmp(t, typeid(DoubleVector).name()) == 0)
        return true;
    if (strcmp(t, typeid(float).name()) == 0)
        return true;
    if (strcmp(t, typeid(double).name()) == 0)
        return true;
    return false;
}

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::demultiplexCrossoverType(
                                        GAUtils::CrossoverFunctionType cft)
{
    switch (cft) {
        case GAUtils::CrossoverConvex:
            if (continuousOptimization(typeid(IT).name()))
                crossoverFunctionPointerTM = &GAUtils::crossoverConvex<IT>;
            else
                throw GAError("You can't use convex crossover with "
                              "this input type");
            break;

        case GAUtils::CrossoverScattered:
            if (continuousOptimization(typeid(IT).name()))
                crossoverFunctionPointerTM = &GAUtils::crossoverScattered<IT>;
            else
                throw GAError("You can't use scattered crossover with "
                              "this input type");
            break;

        default:
            throw GAError("Invalid operator function identificator");
    }
}

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::demultiplexMutationType(
                                        GAUtils::MutationFunctionType mft)
{
    switch (mft) {
        case GAUtils::MutationGaussian:
            if (continuousOptimization(typeid(IT).name()))
                mutationFunctionPointerTM = &GAUtils::mutationGaussian<IT>;
            else
                throw GAError("You can't use gaussian mutation "
                              "with this input type");
            break;

        default:
            throw GAError("Invalid mutation operator identificator");
    }
}

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::commonConstructor()
{
    /* Input checking. */
    if (!isOutputTypeValid(typeid(OT).name()))
        throw GAError("Bad output type");

    /* The following parameters will be initialized just before running
       the algorithm. */
    N = 0;
    maxGenerations = -1; CF = -1.0; NEC = -1; MF = -1.0; MP = -1;

    sendBuffer = NULL;
    receiveBuffer = NULL;
    pointersBuffer = NULL;
    receivedIndividualsScores = NULL;

    cout << "My unique is " << server.get_unique() <<
            ", prev = " << server.get_prev().to_string() <<
            ", succ = " << server.get_succ().to_string() << "\n";

    std::cout << "A genetic algorithm object was generated!\n";

}

/* User provided mutation function and crossover function. */
template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm(FitnessFunctionPT ffpt,
                                          MutationFunctionPT mfpt,
                                          CrossoverFunctionPT cfpt,
                                          GAUtils::SelectionFunctionType sft,
                                          GAPeerServer& _server
                                        ) : fitnessFunctionPointer(ffpt),
                                            mutationFunctionPointer(mfpt),
                                            mutationFunctionPointerTM(NULL),
                                            crossoverFunctionPointer(cfpt),
                                            crossoverFunctionPointerTM(NULL),
                                            population(NULL),
                                            nextPopulation(NULL),
                                            selectedParents(NULL),
                                            infoHeap(0),
                                            SFType(sft),
                                            server(_server),
                                            gaUtils(_server)
{
    commonConstructor();
}

/* User provided mutation function and library local crossover function. */
template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm(FitnessFunctionPT ffpt,
                                          MutationFunctionPT mfpt,
                                          GAUtils::CrossoverFunctionType cft,
                                          GAUtils::SelectionFunctionType sft,
                                          GAPeerServer& _server
                                        ) : fitnessFunctionPointer(ffpt),
                                            mutationFunctionPointer(mfpt),
                                            mutationFunctionPointerTM(NULL),
                                            crossoverFunctionPointer(NULL),
                                            population(NULL),
                                            nextPopulation(NULL),
                                            selectedParents(NULL),
                                            infoHeap(0),
                                            SFType(sft),
                                            server(_server),
                                            gaUtils(_server)
{
    commonConstructor();
    /* Demultiplexing crossover function enumeration. */
    demultiplexCrossoverType(cft);
}

/* library local mutation function and user provided crossover function. */
template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm(FitnessFunctionPT ffpt,
                                          GAUtils::MutationFunctionType mft,
                                          CrossoverFunctionPT cfpt,
                                          GAUtils::SelectionFunctionType sft,
                                          GAPeerServer& _server
                                        ) : fitnessFunctionPointer(ffpt),
                                            mutationFunctionPointer(NULL),
                                            mutationFunctionType(mft),
                                            crossoverFunctionPointer(cfpt),
                                            crossoverFunctionPointerTM(NULL),
                                            population(NULL),
                                            nextPopulation(NULL),
                                            selectedParents(NULL),
                                            infoHeap(0),
                                            SFType(sft),
                                            server(_server),
                                            gaUtils(_server)
{
    commonConstructor();
    /* Demultiplexing mutation function enumeration. */
    demultiplexMutationType(mft);
}



/* Library local mutation function and crossover function. */
template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm(FitnessFunctionPT ffpt,
                                          GAUtils::MutationFunctionType mft,
                                          GAUtils::CrossoverFunctionType cft,
                                          GAUtils::SelectionFunctionType sft,
                                          GAPeerServer& _server
                                        ) : fitnessFunctionPointer(ffpt),
                                            mutationFunctionPointer(NULL),
                                            mutationFunctionType(mft),
                                            crossoverFunctionPointer(NULL),
                                            population(NULL),
                                            nextPopulation(NULL),
                                            selectedParents(NULL),
                                            infoHeap(0),
                                            SFType(sft),
                                            server(_server),
                                            gaUtils(_server)
{
    commonConstructor();
    /* Demultiplexing crossover function enumeration */
    demultiplexCrossoverType(cft);
    /* Demultiplexing mutation function enumeration. */
    demultiplexMutationType(mft);
}

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::performFitnessScaling()
{
    /* This function assumes the heap is full. */
    if (infoHeap.size() != N) {
        throw GAError("Bug: la funzione che effettua il fitness scaling "
                      "ha trovato l'heap non pieno");
    }
    for (unsigned int i=0; i<N; i++) {
        infoHeap.heapArray[i].score = scalingCoeff / sqrt(i + 1);
    }
}

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::stochasticUniversalSampling()
{
    /* --- stochastic universal sampling --- */
    int i = P;      /* number of individuals to select */
    int j = N;      /* population size*/
    float sum = 0;  /* sum of relative fitness values
                       (cumulative fitness value) */
    float mark, inc; /* marker position and increment */

    inc  = 1.0; /* P markers on wheel with a circumference of length P */
    mark = inc * rand_float(); /* choose position of first marker */
    while ((--j >= 0) && (i > 0)) /* traverse the population */
    {
        sum += infoHeap.heapArray[j].score; /* compute end of wheel section */
        while (mark < sum)  /* while next marker is in the section */
        {
            /* Select the individual. */
            selectedParents[--i] = infoHeap.heapArray[j].pointer;
            mark += inc;
        }
    }

    /* If not enough individuals selected, fill with first individual
       (the best one) */
    while (--i >= 0)
        selectedParents[i] = infoHeap.heapArray[0].pointer;
    /*----------------------------------------------------------------------
      The check for (i > 0) in the outer while loop as well as the loop that
      fills the vector of selected individuals are needed due to possible
      roundoff errors in the fitness computations, which may cause too many
      or too few individuals getting selected.
      ----------------------------------------------------------------------*/
}


template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::performParentsSelection()
{
    switch (SFType)
    {
        case GAUtils::SUS:  /* Stochastic universal sampling. */
            stochasticUniversalSampling();
            break;
        case GAUtils::RWS:
            throw GAError("RWS not yet implemented");
            break;
    }
    /* for (int i=0; i<P; i++)
        cout << *(selectedParents[i]) << ", "; cout << "\n";
    */
}

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::shuffleParents()
{
    /* Shuffle array selectedParents implementing Fisher–Yates method
       (Durstenfeld version). */
    for (int i=P-1; i>0; i--)
    {
        /* Generate a random integer number between 0 and i (included). */
        int j = rand_int(0, i);

        IT* tmp = selectedParents[i];
        selectedParents[i] = selectedParents[j];
        selectedParents[j] = tmp;
    }
}


template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::gatherResults()
{
    cout << "Local best individual:" << endl;
    cout << "    " << *(infoHeap.heapArray[0].pointer)
            << ", score = " << infoHeap.heapArray[0].score << endl;
}


/* GA engine. */
template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::gaCore()
{
    /* Evaluates fitness on the initial population. */
    IndividualInfo info;
    for (unsigned int i=0; i<N; i++)
    {
        /* Builds an "IndividualInfo" and inserts it into the heap. */
        info.pointer = &population[i];
        info.score = (*fitnessFunctionPointer)(population[i]);
        infoHeap.insert(info);
    }

    /* Initializes random generator. */
    rand_init(GA_BASE_SEED + GA_MUL_SEED * server.get_unique());

    unsigned int numGenerations = 1;
    unsigned int migrationCountdown = MP;

    /* Main loop. */
    for (;;)
    {
        /* Sorts population by scaled scores. */
        infoHeap.sortLocally();

        if (DEBUG /* && meshInterfacePointer->getMyID()==0 */) {
            cout << "Core " << server.get_unique() <<
                    ", generazione " << numGenerations << ":\n";
            for (unsigned int i=0; i<N; i++)
                cout << *(infoHeap.heapArray[i].pointer) <<
                        ", score = " << infoHeap.heapArray[i].score << "\n";
        }

        /* Carries out migration procedures. */
        if (server.num_peers() > 1 && migrationCountdown == 0) {
            migrationCountdown = MP;

            /* Gets the pointers to the best NMI individuals (here
               infoHeap.heapArray is sorted, so we can pick the first
               elements). */
            for (unsigned int i=0; i<NMI; i++)
                pointersBuffer[i] = infoHeap.heapArray[i].pointer;

            /* Serializes and puts the best NMI individuals in the output
               buffer. */
            gaUtils.serializeAndCopy<IT>(sendBuffer, pointersBuffer, NMI);

            /*
            cout << "Sending... \n";
            for (int i=0; i<NMI; i++)
            cout << *(pointersBuffer[i]) << "\n";
            cout << "\n";
            */

            /* Send a migration message to the succ peer. */
            RemoteConnection connection(server.get_succ());
            MigrationMsg msg(sendBuffer, NMI * sizeof(IT));

            if (connection.open) {
                msg.serialize(connection);
                connection.close();
            } else {
                std::cerr << __func__ << ": Cannot open a connection to "
                            "succ " << server.get_succ().ip << ":" <<
                            server.get_succ().port << endl;
            }

            receiveBuffer->lock();

            if (receiveBuffer->len == 0) {
                /* No migration message received. */
                receiveBuffer->unlock();
            } else {
                /* Process a received migration message. */

                /* Discards the NMI worst individuals (infoHeap.heapArray is
                   sorted) by decreasing infoheap.lastNode, and puts their
                   address in pointersBuffer. */
                for (unsigned int i=0; i<NMI; i++)
                    pointersBuffer[i] =
                        infoHeap.heapArray[infoHeap.lastNode--].pointer;
                /* Deserializes the message received and replaces discarded
                   individuals with the received ones. */
                gaUtils.deserializeAndCopy<IT>(receiveBuffer->ptr, pointersBuffer, NMI);

                receiveBuffer->len = 0;
                receiveBuffer->unlock();

                /*
                   cout << "Receiveing... \n";
                   for (int i=0; i<NMI; i++)
                   cout << *(pointersBuffer[i]) << "\n";
                   cout << "\n";
                   */

                /* Computes the fitness of the new individuals. */
                for (unsigned int i=0; i<NMI; i++) {
                    receivedIndividualsScores[i] =
                        (*fitnessFunctionPointer)(*(pointersBuffer[i]));
                }

                /* Merges new individuals with local individuals. */
                int kr = NMI - 1,
                    kh = infoHeap.lastNode,
                    heapIndex = N - 1;
                while (heapIndex >= 0)
                    if (infoHeap.heapArray[kh].score >
                            receivedIndividualsScores[kr]) {
                        infoHeap.heapArray[heapIndex].pointer =
                            infoHeap.heapArray[kh].pointer;
                        infoHeap.heapArray[heapIndex--].score =
                            infoHeap.heapArray[kh--].score;
                    } else {
                        infoHeap.heapArray[heapIndex].pointer =
                            pointersBuffer[kr];
                        infoHeap.heapArray[heapIndex--].score =
                            receivedIndividualsScores[kr--];
                    }
                infoHeap.lastNode = N - 1;
            }
        }

        /* Scales raw fitnesses. */
        performFitnessScaling();

        /* Selects parents for reproduction. */
        performParentsSelection();

        /* Crossover function are designed in such a way that only parents
           which are consecutive in the array "selectedParents" are going to
           mating; moreover, crossover is performed only over the elements
           [0:CP-1], while mutation is performed on the elements [CP:P-1];
           for these reasons at this point we have to shuffle the array by
           generating a random permutation.
        */
        shuffleParents();

        /* Generate the elite children copying the best individuals of the
           current population. */
        for (unsigned int i=0; i<NEC; i++)
            nextPopulation[i] = *(infoHeap.heapArray[i].pointer);

        /* Performs crossover and stores resulting children in
           nextPopulation[0:NCC-1]. */
        if (crossoverFunctionPointer != NULL) {
            /* Calls user provided (global) function. */
            for (unsigned int i=NEC, spi=0; i<NEC+NCC; i++, spi+=2)
                (*crossoverFunctionPointer)(*(selectedParents[ spi ]),
                                            *(selectedParents[ spi+1 ]),
                                            nextPopulation[i]);
        } else {
            /* Calls GAUtils member function, by deferentiating the
               pointer to member. */
            for (unsigned int i=NEC, spi=0; i<NEC+NCC; i++, spi+=2)
                (gaUtils.*crossoverFunctionPointerTM)(
                                            *(selectedParents[ spi ]),
                                            *(selectedParents[ spi+1 ]),
                                            nextPopulation[i]);
        }

        /* Performs mutation and stores resulting children in
           nextPopulation[NCC:N-1]. */
        if (mutationFunctionPointer != NULL) {
            /* Calls user provided (global) function. */
            for (unsigned int i=NEC+NCC, spi=CP; i<N; i++, spi++)
                (*mutationFunctionPointer)(*(selectedParents[ spi ]),
                                           nextPopulation[i]);
        } else {
            /* Calls GAUtils member function, by deferentiating the
               pointer to member. */
            for (unsigned int i=NEC+NCC, spi=CP; i<N; i++, spi++)
                (gaUtils.*mutationFunctionPointerTM)(
                                            *(selectedParents[ spi ]),
                                            nextPopulation[i]);

            /* Refreshes mutationGaussian parameters. */
            if (mutationFunctionType == GAUtils::MutationGaussian)
                gaUtils.refreshMutationGaussianParameters(numGenerations,
                                                          maxGenerations);
        }

        /* Swap current and next generation. */
        IT* tmp = population;
        population = nextPopulation;
        nextPopulation = tmp;

        /*
           for (int i=0; i<N; i++)
           {
           for (int d=0; d<D; d++)
           cout << population[i][d] << ", ";
           cout << "\n";
           }cout << "\n";system("PAUSE");*/

        /* Evaluates fitness on the new population and builds the new heap. */
        infoHeap.reset();
        IndividualInfo info;
        for (unsigned int i=0; i<N; i++)
        {
            /* Builds an "IndividualInfo" and inserts it into the heap. */
            info.pointer = &population[i];
            info.score = (*fitnessFunctionPointer)(population[i]);
            infoHeap.insert(info);
        }

        numGenerations++;
        if (numGenerations == maxGenerations)
            break;
        migrationCountdown--;
    }

    infoHeap.sortLocally();

    if (!DEBUG) {
        cout << "Optimization terminated! Best results:\n";
        for (unsigned int i=0; i<((N>3) ? 3 : N); i++)
            cout << "(" << i+1 << ") " << *(infoHeap.heapArray[i].pointer) <<
                    ", score " << infoHeap.heapArray[i].score << "\n";
        cout << "\n";
    }

    gatherResults();
}


template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::run(const std::vector<IT>& initialPopulation,
                                  unsigned int maxGen, float cf,
                                  unsigned int eliteChildren,
                                  float mf, unsigned int mp)
{
    if (initialPopulation.size() == 0)
        throw GAError("GA.run: population provided is empty");

    bool memOptionsChanged = false;

    /* Refresh options which require memory allocation only if suitable. */
    maxGenerations = maxGen;
    if (cf != CF && cf >= 0.0 && cf <= 1.0) {
        CF = cf;
        memOptionsChanged = true;
    }

    if (eliteChildren != NEC && eliteChildren >= 0 &&
        eliteChildren <= initialPopulation.size()) {
        NEC = eliteChildren;
        memOptionsChanged = true;
    }

    if (mf != MF && mf >= 0.0 and mf <=1.0) {
        MF = mf;
        NMI = static_cast< int >(initialPopulation.size() * mf);
        /* NMI==0 only if mf = 0.0 (isolated computation). */
        if (mf > 0.0 && NMI == 0)
            NMI = 1;

        if (sendBuffer != NULL)
        {
            delete [] sendBuffer;
            delete receiveBuffer;
            delete [] pointersBuffer;
            delete [] receivedIndividualsScores;
        }
        sendBuffer = new uint8_t[ sizeof(IT) * NMI ];
        receiveBuffer = new GAReceiveBuffer(sizeof(IT) * NMI);
        pointersBuffer = new IT*[NMI];
        receivedIndividualsScores = new OT[NMI];
    }
    if (mp > 0)
        MP = mp;

    /* Initializes class GeneticAlgorithm. */
    if (initialPopulation.size() != N)
    {
        /* Allocates memory and refreshes options only if necessary. */
        N = initialPopulation.size();

        if (population != NULL)
        {
            delete [] population;
            delete [] nextPopulation;
        }


        /*cout << "Parameters: " <<  CF << ", " << NEC << ", "
                << maxGenerations << "\n"; */
        population = new IT[ N ];      /* IT default constructor. */
        nextPopulation = new IT[ N ];  /* IT default constructor. */
        infoHeap.reinit(N);

        memOptionsChanged = true;
    }


    if (memOptionsChanged) { /* TODO da raffinare!! */
        /* Initialize population parameters. */
        NCC = static_cast<int>(CF * (N - NEC));
        NMC = N - NEC - NCC;
        /* Two parents for each crossover-generated child and one parent
           for each mutation generated child. */
        CP =  2 * NCC;
        P = CP + NMC;

        delete [] selectedParents;
        selectedParents = new IT*[ P ];

        /* Compute scaling coefficient (fitness scaling). */
        scalingCoeff = 0.0;
        for (unsigned int i=1; i<=N; i++)
            scalingCoeff += 1/sqrt(i);
        scalingCoeff = (P) / scalingCoeff;
    }

    for (unsigned int i=0; i<N; i++)
    {
        /* IT assignment operator, which is assumed to allocate memory
           (so nextPopulation is initialized) */
        population[i] = initialPopulation[i];
        nextPopulation[i] = initialPopulation[i];
    }

    server.set_receive_buffer(receiveBuffer);

    if (DEBUG) cout << "Starting optimization...!\n";
    gaCore();
}





/* -------------------------------------------------------------------------*/
/*                    InfoHeap class implementation                         */
/* -------------------------------------------------------------------------*/

/* Not used at the moment. */
template <class IT, class OT>
GeneticAlgorithm<IT,OT>::InfoHeap::InfoHeap(unsigned int n) : N(n), lastNode(-1)
{
    if (n > 0) {
        /* The last position is reserved and used as a "swap area". */
        heapArray = new IndividualInfo[ n + 1 ];
    }
}

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::reinit(unsigned int n)
{
    if (n <= 0)
        throw GAError(" InfoHeap.init(n): n must be > 0 ");
    if (N != n) {
        /* Deallocates and reallocates only if necessary. */
        if (N)
            delete [] heapArray;
        N = n;
        lastNode = -1;
        /* The last position is reserved and used as a "swap area". */
        heapArray = new IndividualInfo[ N + 1 ];
    }
}

// XXX (const IndividualInfo& element)     ?????
template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::insert(IndividualInfo element)
{
    //cout << "heap last position = " << lastNode+1 << "\n";
    if (lastNode == static_cast<int>(N-1))
        throw GAError("Bug: lo heap è andato in overflow durante un "
                      "tentativo di inserimento");
    heapArray[ ++lastNode ] = element;

    /* Execute the "up" procedure iteratively. */
    int currentIndex = lastNode, parentIndex;
    for (;;)
    {
        parentIndex = (currentIndex - 1) / 2;
        if (heapArray[ currentIndex ].score > heapArray[ parentIndex ].score)
        {
            /* Swaps using the "swap area". */
            heapArray[ N ] = heapArray[ currentIndex ];
            heapArray[ currentIndex ] = heapArray[ parentIndex ];
            heapArray[ parentIndex ] = heapArray[ N ];
            currentIndex = parentIndex;
        }
        else
            break;
    }
}

template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::sortLocally()
{
    int hi = lastNode;
    while (hi) {
        /* Swap the root with the current actual position. */
        heapArray[ N ] = heapArray[ 0 ];
        heapArray[ 0 ] = heapArray[ hi ];
        heapArray[ hi-- ] = heapArray[ N ];

        /* Execute the "down" procedure iteratively. */
        int currentIndex = 0, sonIndex;
        for (;;) {
            sonIndex = 2 * currentIndex + 1;
            if (sonIndex == hi) {
                if (heapArray[ sonIndex ].score >
                        heapArray[ currentIndex ].score) {
                    heapArray[ N ] = heapArray[ currentIndex ];
                    heapArray[ currentIndex ] = heapArray[ sonIndex ];
                    heapArray[ sonIndex ] = heapArray[ N ];
                }
                break;
            } else if (sonIndex < hi) {
                if (heapArray[ sonIndex + 1 ].score >
                        heapArray[ sonIndex ].score)
                    sonIndex++;
                if (heapArray[ sonIndex ].score >
                        heapArray[ currentIndex ].score) {
                    heapArray[ N ] = heapArray[ currentIndex ];
                    heapArray[ currentIndex ] = heapArray[ sonIndex ];
                    heapArray[ sonIndex ] = heapArray[ N ];
                    currentIndex = sonIndex;
                } else
                    break;
            } else
                break;
        }
    }
}


template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::print() const
{
    for (int i=0; i<N; i++)
        std::cout << "Individual: " << (*(heapArray[i].pointer)) <<
                     ", score = " << heapArray[i].score << "\n";
}

#endif
