#ifndef GENETIC_ALGORITHM_
#define GENETIC_ALGORITHM_

#include <iostream>
#include <typeinfo>  // for RTTI
#include <vector>
#include <string>
#include <cmath>
#include <cstring>


using namespace std; // per colpa dell'operatore ostream& operator<< di IT

#include "GAError.h"
#include "GAUtils.h"

#define DEBUG 0


/************************** MAIN CLASS DECLARATION ****************************/

template <class IT, class OT>
class GeneticAlgorithm
{ 
    private:
        typedef OT ( *FitnessFunctionPT )( const IT& );
        FitnessFunctionPT fitnessFunctionPointer;

        typedef void ( *MutationFunctionPT )( const IT&, IT& );
        MutationFunctionPT mutationFunctionPointer;
        GAUtils::MutationFunctionType mutationFunctionType;

        typedef void ( *CrossoverFunctionPT )( const IT&, const IT&, IT& );
        CrossoverFunctionPT crossoverFunctionPointer;

        typedef void ( GAUtils::* MutationFunctionPTTM )( const IT&, IT& );
        MutationFunctionPTTM mutationFunctionPointerTM;

        typedef void ( GAUtils::* CrossoverFunctionPTTM )( const IT&, const IT&, IT& );
        CrossoverFunctionPTTM crossoverFunctionPointerTM;

        void demultiplexCrossoverType( GAUtils::CrossoverFunctionType cft );
        void demultiplexMutationType( GAUtils::MutationFunctionType mft );

        struct IndividualInfo  // data structure corresponding to an individual
        {
            IT* pointer;
            OT score;
        };

        IT* population;   //  array which contains the individuals of the current population
        IT* nextPopulation;  // array built gradually, stores the new individuals
        IT** selectedParents;  // array of pointers to the individuals selected for reproduction

        class InfoHeap  // max-binary-heap class used to store the scores of individuals
        {
            int N;
            public:
            IndividualInfo* heapArray;  // array implementing the binary-heap 

            InfoHeap( int n );    // only used with n == 0
            void reinit( int n );  // used to reinitialize the heap

            int lastNode;  // current index of the last element in the heap
            void reset() { lastNode = -1; }  // makes the heap empty
            void insert( IndividualInfo );  // insert an element into the heap
            void sortLocally();  //  sort the array heapArray using heap-sort
            void print() const;
            int size() const { return ( lastNode + 1 ); }
        };
        InfoHeap infoHeap; // binary-heap structure which contains a data structure for each individual of the current population

        void commonConstructor();

        int N;     // number of individuals of array population
        int NCC;   // number of crossover children (i.e. children generated by crossover)
        int NMC;   // number of mutation children (i.e. children generated by mutation)
        int NEC;   // number of elite children (i.e. children)
        float CF;  // crossover fraction
        int P;     // number of parents required to compute next generation
        int CP;    // number of parents required to compute next generation by recombination
        float MF;  // migration fraction: fraction of the individual that are propagated during migration rounds
        int MP;    // migration period: number of GA iteration between two migration rounds
        int NMI;   // number of migration individuals: number of individuals of the current population which migrate away

        int maxGenerations; // maximum number of iterations of the algorithm

        static const int GA_BASE_SEED = 961114537;
        static const int GA_MUL_SEED = 113;

        bool distribuitedComputation; // true if the genetic algorithm runs on multiple execution units which communicate between them, false otherwise

        MeshByte* sendBuffer;
        MeshByte* receiveBuffer;
        IT** pointersBuffer;
        OT* receivedIndividualsScores;
        SccMeshInterface* meshInterfacePointer;
        int prev, succ;
        NodeColor myColor;


        GAUtils::SelectionFunctionType SFType;

        double scalingCoeff;
        void performFitnessScaling(); // MATLAB rankScaling

        void performParentsSelection();  // chooses P individuals from the current population
        void stochasticUniversalSampling();

        void shuffleParents();  // shuffles selected parents

        void gaCore();

        void gatherResults();

        bool isOutputTypeValid( const char* t ) const;
        bool continuousOptimization( const char* t ) const;
    public:
        GeneticAlgorithm( FitnessFunctionPT ffpt, MutationFunctionPT mfpt, CrossoverFunctionPT cfpt, GAUtils::SelectionFunctionType sft );
        GeneticAlgorithm( FitnessFunctionPT ffpt, MutationFunctionPT mfpt, GAUtils::CrossoverFunctionType cft, GAUtils::SelectionFunctionType sft );
        GeneticAlgorithm( FitnessFunctionPT ffpt, GAUtils::MutationFunctionType mft, CrossoverFunctionPT cfpt, GAUtils::SelectionFunctionType sft );
        GeneticAlgorithm( FitnessFunctionPT ffpt, GAUtils::MutationFunctionType mft, GAUtils::CrossoverFunctionType cft, GAUtils::SelectionFunctionType sft );

        void run( const std::vector<IT>& initialPopulation, int maxGen = 100, float cf = 0.8, int eliteChildren = 3, float mf = 0.1, int mi = 20 ); // run the genetic algorithm with a user-provided initial population

        GAUtils gaUtils;  // allows to generate random initial populations
};




/******************************************************************************/
/*                      GeneticAlgorithm class implementation                 */
/******************************************************************************/

template <class IT, class OT>
bool GeneticAlgorithm<IT,OT>::isOutputTypeValid( const char* t ) const
{
    if ( strcmp( t, typeid( float ).name() ) == 0 )
        return true;
    else if ( strcmp( t, typeid( double ).name() ) == 0 )
        return true;
    else if ( strcmp( t, typeid( int ).name() ) == 0 )
        return true;
    else if ( strcmp( t, typeid( long int ).name() ) == 0 )
        return true;
    else if ( strcmp( t, typeid( short int ).name() ) == 0 )
        return true;
    return false;
}


template <class IT, class OT>
bool GeneticAlgorithm<IT,OT>::continuousOptimization( const char* t ) const
{
    if ( strcmp( t, typeid( FloatVector ).name() ) == 0 )
        return true;
    if ( strcmp( t, typeid( DoubleVector ).name() ) == 0 )
        return true;
    if ( strcmp( t, typeid( float ).name() ) == 0 )
        return true;
    if ( strcmp( t, typeid( double ).name() ) == 0 )
        return true;
    return false;
}

    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::demultiplexCrossoverType( GAUtils::CrossoverFunctionType cft )
{
    switch ( cft )
    {
        case GAUtils::CrossoverConvex:
            if ( continuousOptimization( typeid( IT ).name() ) )
                crossoverFunctionPointerTM = &GAUtils::crossoverConvex<IT>; 
            else
                throw GAError( "You can't use convex crossover with this input type" );
            break;

        case GAUtils::CrossoverScattered:
            if ( continuousOptimization( typeid( IT ).name() ) )
                crossoverFunctionPointerTM = &GAUtils::crossoverScattered<IT>;
            else
                throw GAError( "You can't use scattered crossover with this input type" );
            break;

        default:
            throw GAError( "Invalid operator function identificator" );
    }
}

    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::demultiplexMutationType( GAUtils::MutationFunctionType mft )
{
    switch ( mft )
    {
        case GAUtils::MutationGaussian:
            if ( continuousOptimization( typeid( IT ).name() ) )
                mutationFunctionPointerTM = &GAUtils::mutationGaussian<IT>;
            else
                throw GAError( "You can't use gaussian mutation with this input type" );
            break;

        default:
            throw GAError( "Invalid mutation operator identificator" );
    }
}

    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::commonConstructor()
{
    // Input checking
    if ( !isOutputTypeValid( typeid( OT ).name() ) )
        throw GAError( "Bad output type" );

    // the following parameters will be initialized just before running the algorithm
    N = 0;
    maxGenerations = -1; CF = -1.0; NEC = -1; MF = -1.0; MP = -1;

    meshInterfacePointer = new SccMeshInterface();

    gaUtils.setMeshInterfacePointer( meshInterfacePointer );

    meshInterfacePointer->getMyMeshConfiguration( prev, succ, myColor );
    if ( prev == -1 ) // (prev==-1) if and only if (succ==-1)
        distribuitedComputation = false;
    else
        distribuitedComputation = true;

    sendBuffer = receiveBuffer = NULL;
    pointersBuffer = NULL;
    receivedIndividualsScores = NULL;

    cout << "My ID is " << meshInterfacePointer->getMyID() << ", my color is " << ((myColor==MPL_RED) ? "RED" : "BLACK") << ", prevID = " << prev << ", succID = " << succ << "\n";

}

// user provided mutation function and crossover functon
    template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm( FitnessFunctionPT ffpt, MutationFunctionPT mfpt, CrossoverFunctionPT cfpt, GAUtils::SelectionFunctionType sft ) : fitnessFunctionPointer( ffpt ), mutationFunctionPointer( mfpt ), mutationFunctionPointerTM( NULL ), crossoverFunctionPointer( cfpt ), crossoverFunctionPointerTM( NULL ), SFType( sft ), infoHeap( 0 ), population( NULL ), nextPopulation( NULL ), selectedParents( NULL )
{
    commonConstructor();
    std::cout << "A genetic algorithm object was generated!\n";
}

// user provided mutation function and library local crossover functon
    template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm( FitnessFunctionPT ffpt, MutationFunctionPT mfpt, GAUtils::CrossoverFunctionType cft, GAUtils::SelectionFunctionType sft ) : fitnessFunctionPointer( ffpt ), mutationFunctionPointer( mfpt ), mutationFunctionPointerTM( NULL ), crossoverFunctionPointer( NULL ), SFType( sft ), infoHeap( 0 ), population( NULL ), nextPopulation( NULL ), selectedParents( NULL )
{
    commonConstructor();
    // demultiplexing crossover function enumeration
    demultiplexCrossoverType( cft );
    std::cout << "A genetic algorithm object was generated!\n";
}

// library local mutation function and user provided crossover functon
    template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm( FitnessFunctionPT ffpt, GAUtils::MutationFunctionType mft, CrossoverFunctionPT cfpt, GAUtils::SelectionFunctionType sft ) : fitnessFunctionPointer( ffpt ), mutationFunctionPointer( NULL ), mutationFunctionType( mft ), crossoverFunctionPointer( cfpt ), crossoverFunctionPointerTM( NULL ), SFType( sft ), infoHeap( 0 ), population( NULL ), nextPopulation( NULL ), selectedParents( NULL )
{
    commonConstructor();
    // demultiplexing mutation function enumeration
    demultiplexMutationType( mft );
    std::cout << "A genetic algorithm object was generated!\n";
}



// library local mutation function and crossover functon
    template <class IT, class OT>
GeneticAlgorithm<IT,OT>::GeneticAlgorithm( FitnessFunctionPT ffpt, GAUtils::MutationFunctionType mft, GAUtils::CrossoverFunctionType cft, GAUtils::SelectionFunctionType sft ) : fitnessFunctionPointer( ffpt ), mutationFunctionPointer( NULL ), mutationFunctionType( mft ), crossoverFunctionPointer( NULL ), SFType( sft ), infoHeap( 0 ), population( NULL ), nextPopulation( NULL ), selectedParents( NULL )
{
    commonConstructor();
    // demultiplexing crossover function enumeration
    demultiplexCrossoverType( cft );
    // demultiplexing mutation function enumeration
    demultiplexMutationType( mft );
    std::cout << "A genetic algorithm object was generated!\n";
}

    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::performFitnessScaling()
{
    // this function assumes the heap is full
    if ( infoHeap.size() != N )
        throw GAError( "Bug: la funzione che effettua il fitness scaling ha trovato l'heap non pieno" );
    for ( int i=0; i<N; i++ )
        infoHeap.heapArray[i].score = scalingCoeff / sqrt( i + 1 );
}

    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::stochasticUniversalSampling()
{
    /* --- stochastic universal sampling --- */
    int i = P;                   /* number of individuals to select */
    int j = N;                   /* population size*/
    float sum = 0;               /* sum of relative fitness values (cumulative fitness value) */
    float mark, inc;             /* marker position and increment */

    inc  = 1.0; // inc = P/P;    /* P markers on wheel with a circumference of length P */
    mark = inc * rand_float();         /* choose position of first marker */
    while ( (--j >= 0) && (i > 0) )  /* traverse the population */
    {   
        sum += infoHeap.heapArray[j].score;     /* compute end of wheel section */
        while (mark < sum)        /* while next marker is in the section */
        {     
            selectedParents[--i] = infoHeap.heapArray[j].pointer; /* select the individual */
            mark += inc; 
        }
    }                        
    while (--i >= 0)                                       /* if not enough individuals selected, */
        selectedParents[i] = infoHeap.heapArray[0].pointer;  /* fill with first individual (the best one) */
    /*----------------------------------------------------------------------
      The check for (i > 0) in the outer while loop as well as the loop that
      fills the vector of selected individuals are needed due to possible
      roundoff errors in the fitness computations, which may cause too many
      or too few individuals getting selected.
      ----------------------------------------------------------------------*/
} 


    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::performParentsSelection()
{
    switch ( SFType )
    {
        case GAUtils::SUS:  // Stochastic universal sampling
            stochasticUniversalSampling();
            break;
        case GAUtils::RWS:
            throw GAError( "RWS not yet implemented" );
            break;
    }
    //for ( int i=0; i<P; i++ ) cout << *(selectedParents[i]) << ", "; cout << "\n";
}

    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::shuffleParents()
{
    // shuffle array selectedParents implementing Fisher–Yates method (Durstenfeld version)
    for ( int i=P-1; i>0; i-- )
    {
        int j = rand_int( 0, i );  // generate a random integer number between 0 and i (included)
        IT* tmp = selectedParents[i];
        selectedParents[i] = selectedParents[j];
        selectedParents[j] = tmp;
    }
}


    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::gatherResults()
{
    if ( meshInterfacePointer->getMyID() == 0 )
    {
        int numCores = meshInterfacePointer->numberOfActiveCores();
        IT** bestIndividuals = new IT*[numCores];
        OT* bestScores = new  OT[numCores];
        for ( int i=0; i<numCores; i++ )
            bestIndividuals[i] = new IT( population[0] ); // we do this copy only to call the copy constructor, so that memory is allocated for the new objects (if necessary)

        bestIndividuals[0] = infoHeap.heapArray[0].pointer;
        bestScores[0] = infoHeap.heapArray[0].score;
        for ( int i=1; i<numCores; i++ )
        {
            meshInterfacePointer->receiveIndividuals( receiveBuffer, sizeof( IT ), i );
            gaUtils.deserializeAndCopy<IT>( receiveBuffer, &bestIndividuals[i], 1 );
            bestScores[i] = ( *fitnessFunctionPointer )( *( bestIndividuals[i] ) ) ;
        }
        cout << "Global best individuals:\n";
        for ( int i=0; i<numCores; i++ )
            cout << "(" << i + 1 << ")  " << *( bestIndividuals[i] ) << ", score = " << bestScores[i] << "\n";
        delete [] bestIndividuals;
        delete [] bestScores;
    }
    else
    {
        IT** bestIndividual = new IT*;
        *bestIndividual = infoHeap.heapArray[0].pointer;
        gaUtils.serializeAndCopy<IT>( sendBuffer, bestIndividual, 1 );
        meshInterfacePointer->sendIndividuals( sendBuffer, sizeof( IT ), 0 );
        delete *bestIndividual;
    }
}


// GA engine
    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::gaCore()
{                                   
    // evaluates fitness on the initial population
    IndividualInfo info;
    for ( int i=0; i<N; i++ )
    {
        // builds an "IndividualInfo" and inserts it into the heap
        info.pointer = &population[i];
        info.score = ( *fitnessFunctionPointer )( population[i] ); 
        infoHeap.insert( info );
    }

    rand_init( GA_BASE_SEED + GA_MUL_SEED * meshInterfacePointer->getMyID() );   // initializes random generator

    int numGenerations = 1;
    int migrationCountdown = MP;
    for ( ;; )  // main cycle  
    {
        infoHeap.sortLocally();  // sorts population by scaled scores

        //if ( meshInterfacePointer->getMyID()==0 ) cout << numGenerations << "\n";
        if ( 1 || DEBUG /* && meshInterfacePointer->getMyID()==0 */) {  
            cout << "Core " << meshInterfacePointer->getMyID() << ", generazione " << numGenerations << ":\n";
            for ( int i=0; i<N; i++ )
                cout << *(infoHeap.heapArray[i].pointer) << ", score = " << infoHeap.heapArray[i].score << "\n";
        }

        if ( distribuitedComputation && migrationCountdown == 0 )  // carries out migration procedures
        {
            migrationCountdown = MP;

            // gets the pointers to the best NMI individuals (here infoHeap.heapArray is sorted, so we can pick the first elements)
            for ( int i=0; i<NMI; i++ )
                pointersBuffer[i] = infoHeap.heapArray[i].pointer;
            // serializes and puts the best NMI individuals in the output buffer
            gaUtils.serializeAndCopy<IT>( sendBuffer, pointersBuffer, NMI );

            /*cout << "Sending... \n";
              for ( int i=0; i<NMI; i++ )
              cout << *(pointersBuffer[i]) << "\n";
              cout << "\n";*/

            if ( myColor == MPL_RED )
            {
                meshInterfacePointer->sendIndividuals( sendBuffer, NMI * sizeof( IT ), succ );
                meshInterfacePointer->receiveIndividuals( receiveBuffer, NMI * sizeof( IT ), prev );
            }
            else // ( myColor == MPL_BLACK )
            {
                meshInterfacePointer->receiveIndividuals( receiveBuffer, NMI * sizeof( IT ), prev );
                meshInterfacePointer->sendIndividuals( sendBuffer, NMI * sizeof( IT ), succ );
            }

            // discards the NMI worst individuals (infoHeap.heapArray is sorted) by decreasing infoheap.lastNode, and puts their address in pointersBuffer
            for ( int i=0; i<NMI; i++ )
                pointersBuffer[i] = infoHeap.heapArray[infoHeap.lastNode--].pointer;
            // deserializes the message received and replaces discarded individuals with the received ones
            gaUtils.deserializeAndCopy<IT>( receiveBuffer, pointersBuffer, NMI );

            /*cout << "Receiveing... \n";
              for ( int i=0; i<NMI; i++ )
              cout << *(pointersBuffer[i]) << "\n";
              cout << "\n"; */

            // computes the fitness of the new individuals
            for ( int i=0; i<NMI; i++ )
                receivedIndividualsScores[i] = ( *fitnessFunctionPointer )( *( pointersBuffer[i] ) );

            // merges new individuals with local individuals
            int kr = NMI - 1,
                kh = infoHeap.lastNode,
                heapIndex = N - 1;
            while ( heapIndex >= 0 )
                if ( infoHeap.heapArray[kh].score > receivedIndividualsScores[kr] )
                {
                    infoHeap.heapArray[heapIndex].pointer = infoHeap.heapArray[kh].pointer;
                    infoHeap.heapArray[heapIndex--].score = infoHeap.heapArray[kh--].score;
                }
                else
                {
                    infoHeap.heapArray[heapIndex].pointer = pointersBuffer[kr];
                    infoHeap.heapArray[heapIndex--].score = receivedIndividualsScores[kr--];
                }
            infoHeap.lastNode = N - 1; 
        }

        performFitnessScaling();   // scales raw fitnesses

        performParentsSelection();  // selects parents for reproduction

        /* crossover function are designed in such a way that only parents which are
           consecutive in the array "selectedParents" are going to mating; moreover,
           crossover is performed only over the elements [0:CP-1], while mutation is
           performed on the elements [CP:P-1]; for these reasons at this point we
           have to shuffle the array by generating a random permutation */
        shuffleParents();

        // generate the elite children copying the best individuals of the current population
        for ( int i=0; i<NEC; i++ )
            nextPopulation[i] = *( infoHeap.heapArray[i].pointer );

        // performs crossover and stores resulting children in nextPopulation[0:NCC-1]
        if ( crossoverFunctionPointer != NULL ) // calls user provided (global) function
            for ( int i=NEC, spi=0; i<NEC+NCC; i++, spi+=2 )
                ( *crossoverFunctionPointer )( *( selectedParents[ spi ] ), *( selectedParents[ spi+1 ] ), nextPopulation[i] );
        else  // calls GAUtils member function, by deferentiating the pointer to member
            for ( int i=NEC, spi=0; i<NEC+NCC; i++, spi+=2 )
                ( gaUtils.*crossoverFunctionPointerTM )( *( selectedParents[ spi ] ), *( selectedParents[ spi+1 ] ), nextPopulation[i] );



        // performs mutation and stores resulting children in nextPopulation[NCC:N-1]
        if ( mutationFunctionPointer != NULL ) // calls user provided (global) function
            for ( int i=NEC+NCC, spi=CP; i<N; i++, spi++ )
                ( *mutationFunctionPointer )( *( selectedParents[ spi ] ), nextPopulation[i] );
        else  // calls GAUtils member function, by deferentiating the pointer to member
        {
            for ( int i=NEC+NCC, spi=CP; i<N; i++, spi++ )
                ( gaUtils.*mutationFunctionPointerTM )( *( selectedParents[ spi ] ), nextPopulation[i] );

            if ( mutationFunctionType == GAUtils::MutationGaussian )  // refreshes mutationGaussian parameters
                gaUtils.refreshMutationGaussianParameters( numGenerations, maxGenerations );			  
        }

        // swap current and next generation
        IT* tmp = population;
        population = nextPopulation;
        nextPopulation = tmp;

        /*
           for ( int i=0; i<N; i++ )
           {
           for ( int d=0; d<D; d++ )
           cout << population[i][d] << ", ";
           cout << "\n";
           }cout << "\n";system("PAUSE");*/

        // evaluates fitness on the new population and builds the new heap
        infoHeap.reset();
        IndividualInfo info;
        for ( int i=0; i<N; i++ )
        {	
            // builds an "IndividualInfo" and inserts it into the heap
            info.pointer = &population[i];
            info.score = ( *fitnessFunctionPointer )( population[i] ); 
            infoHeap.insert( info );
        }

        numGenerations++;
        if ( numGenerations == maxGenerations )
            break;
        migrationCountdown--;
    }

    infoHeap.sortLocally();

    if ( !DEBUG ) {
        cout << "Optimization terminated! Best results:\n";
        for ( int i=0; i<( (N>3) ? 3 : N ); i++ ) cout << "(" << i+1 << ") " << *(infoHeap.heapArray[i].pointer) << ", score " << infoHeap.heapArray[i].score << "\n"; cout << "\n";
    }

    gatherResults();
}


    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::run( const std::vector<IT>& initialPopulation, int maxGen, float cf, int eliteChildren, float mf, int mp)
{ 
    if ( initialPopulation.size() == 0 )
        throw GAError( "GA.run: population provided is empty" );


    bool memOptionsChanged = false;
    // refresh options which require memory allocation only if suitable
    maxGenerations = maxGen;
    if ( cf != CF && cf >= 0.0 && cf <= 1.0 )
    {
        CF = cf;
        memOptionsChanged = true;
    }
    if ( eliteChildren != NEC && eliteChildren >= 0 && eliteChildren <= initialPopulation.size() )
    {
        NEC = eliteChildren;
        memOptionsChanged = true;
    }
    if ( mf != MF && mf >= 0.0 and mf <=1.0 )
    {
        MF = mf;
        NMI = static_cast< int >( initialPopulation.size() * mf );
        if ( mf > 0.0 && NMI == 0 ) // NMI==0 only if mf = 0.0 ( isolated computation )
            NMI = 1;

        if ( sendBuffer != NULL )
        {
            delete [] sendBuffer;
            delete [] receiveBuffer;
            delete [] pointersBuffer;
            delete [] receivedIndividualsScores;
        }
        sendBuffer = new MeshByte[ sizeof( IT ) * NMI ];
        receiveBuffer = new MeshByte[ sizeof( IT ) * NMI ];
        pointersBuffer = new IT*[NMI];
        receivedIndividualsScores = new OT[NMI];
    }
    if ( mp > 0 )
        MP = mp;

    // initializes class GeneticAlgorithm
    if ( initialPopulation.size() != N )  // allocates memory and refreshes options only if necessary
    {
        N = initialPopulation.size();

        if ( population != NULL )
        {
            delete [] population;
            delete [] nextPopulation;
        }


        //cout << "Parameters: " <<  CF << ", " << NEC << ", " << maxGenerations << "\n";
        population = new IT[ N ];      // IT default constructor
        nextPopulation = new IT[ N ];  // IT default constructor
        infoHeap.reinit( N );

        memOptionsChanged = true;     
    }


    if ( memOptionsChanged )  // da raffinare!!
    {
        // initialize population parameters
        NCC = static_cast<int>( CF * ( N - NEC ) );
        NMC = N - NEC - NCC;
        // two parents for each crossover-generated child and one parent for each mutation generated child
        CP =  2 * NCC;
        P = CP + NMC;

        delete [] selectedParents;
        selectedParents = new IT*[ P ];

        // compute scaling coefficient (fitness scaling)
        scalingCoeff = 0.0;
        for ( int i=1; i<=N; i++ )
            scalingCoeff += 1/sqrt(i);
        scalingCoeff = ( P ) / scalingCoeff;
    }

    for ( int i=0; i<N; i++ )
    {
        population[i] = initialPopulation[i];  /* IT assignment operator, which is assumed to allocate memory (so nextPopulation is initialized) */
        nextPopulation[i] = initialPopulation[i];
    }

    if ( DEBUG ) cout << "Starting optimization...!\n";  
    gaCore();
}





/* ---------------------------------------------------------------------------*/
/*                    InfoHeap class implementation                           */
/* ---------------------------------------------------------------------------*/

// not used at the moment
    template <class IT, class OT>
GeneticAlgorithm<IT,OT>::InfoHeap::InfoHeap( int n ) : lastNode( -1 ), N( n )
{
    if ( n > 0 )
        heapArray = new IndividualInfo[ n + 1 ];  // the last position is reserved and used as a "swap area"
    // else do nothing
}

    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::reinit( int n )
{
    if ( n <= 0 )
        throw GAError( " InfoHeap.init( n ): n must be > 0 " );
    if ( N != n ) // deallocates and reallocates only if necessary
    {
        if ( N ) 
            delete [] heapArray;
        N = n;
        lastNode = -1;
        heapArray = new IndividualInfo[ N + 1 ];  // the last position is reserved and used as a "swap area"
    }
}

    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::insert( IndividualInfo element )  /// ( const IndividualInfo& element )     ?????
{
    //cout << "heap last position = " << lastNode+1 << "\n";
    if ( lastNode == N-1 )
        throw GAError( "Bug: lo heap è andato in overflow durante un tentativo di inserimento" );
    heapArray[ ++lastNode ] = element;
    // execute the "up" procedure iteratively
    int currentIndex = lastNode, parentIndex;
    for ( ;; )
    {
        parentIndex = ( currentIndex - 1 ) / 2;
        if ( heapArray[ currentIndex ].score > heapArray[ parentIndex ].score )
        {
            // swaps using the "swap area"
            heapArray[ N ] = heapArray[ currentIndex ];
            heapArray[ currentIndex ] = heapArray[ parentIndex ];
            heapArray[ parentIndex ] = heapArray[ N ];
            currentIndex = parentIndex;
        }
        else 
            break;
    }
}

    template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::sortLocally()
{ 
    int hi = lastNode;
    while ( hi )
    { 
        // swap the root with the current actual position 
        heapArray[ N ] = heapArray[ 0 ];
        heapArray[ 0 ] = heapArray[ hi ];
        heapArray[ hi-- ] = heapArray[ N ];

        // execute the "down" procedure iteratively
        int currentIndex = 0, sonIndex;
        for ( ;; )
        {
            sonIndex = 2 * currentIndex + 1;
            if ( sonIndex == hi )
            {
                if ( heapArray[ sonIndex ].score > heapArray[ currentIndex ].score )
                {
                    heapArray[ N ] = heapArray[ currentIndex ];
                    heapArray[ currentIndex ] = heapArray[ sonIndex ];
                    heapArray[ sonIndex ] = heapArray[ N ];
                }
                break;
            }
            else if ( sonIndex < hi )
            {
                if ( heapArray[ sonIndex + 1 ].score > heapArray[ sonIndex ].score )
                    sonIndex++;
                if ( heapArray[ sonIndex ].score > heapArray[ currentIndex ].score )
                {
                    heapArray[ N ] = heapArray[ currentIndex ];
                    heapArray[ currentIndex ] = heapArray[ sonIndex ];
                    heapArray[ sonIndex ] = heapArray[ N ];
                    currentIndex = sonIndex;
                } 
                else break;
            }
            else
                break;  
        }  
    }
}


template <class IT, class OT>
void GeneticAlgorithm<IT,OT>::InfoHeap::print() const
{
    for ( int i=0; i<N; i++ )
        std::cout << "Individual: " << ( *( heapArray[i].pointer ) ) << ", score = " << heapArray[i].score << "\n";
}

#endif
